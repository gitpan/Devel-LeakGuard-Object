.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::LeakGuard::Object 3"
.TH Devel::LeakGuard::Object 3 "2009-06-14" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::LeakGuard::Object \- Scoped checks for object leaks
.SH "VERSION"
.IX Header "VERSION"
This document describes Devel::LeakGuard::Object version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # Track a single object
\&  use Devel::LeakGuard::Object;
\&  my $obj = Foo::Bar\->new;
\&  Devel::LeakGuard::Object::track($obj);
\&  
\&  # Track every object
\&  use Devel::LeakGuard::Object qw( GLOBAL_bless );
\&
\&  # Track every object, summary at exit
\&  use Devel::LeakGuard::Object qw( GLOBAL_bless :at_end );
\&
\&  # Track a block of code, warning on leaks
\&  leakguard {
\&    # your potentially leaky code here
\&  };
\&
\&  # Track a block of code, die on leaks
\&  leakguard {
\&    # your potentially leaky code here
\&  }
\&  on_leak => \*(Aqdie\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides tracking of objects, for the purpose of
detecting memory leaks due to circular references or innappropriate
caching schemes.
.PP
It is derived from, and backwards compatible with Adam Kennedy's
Devel::Leak::Object. Any errors are mine.
.PP
It works by overridding \f(CW\*(C`bless\*(C'\fR and adding a synthetic \f(CW\*(C`DESTROY\*(C'\fR
method to any tracked classes so that it can maintain a count of blessed
objects per-class.
.PP
Object tracking can be enabled:
.IP "\(bu" 4
for an individual object
.IP "\(bu" 4
for a block of code
.IP "\(bu" 4
globally
.SS "Tracking an individual object"
.IX Subsection "Tracking an individual object"
Track individual objects like this:
.PP
.Vb 1
\&  use Devel::LeakGuard::Object qw( track );
\&
\&  # Later...
\&  track( my $obj = new Foo );
.Ve
.SS "Tracking object leaks in a block of code"
.IX Subsection "Tracking object leaks in a block of code"
To detect any object leaks in a block of code:
.PP
.Vb 1
\&  use Devel::LeakGuard::Object qw( leakguard );
\&
\&  leakguard {
\&    # your code here.
\&  };
.Ve
.SS "Tracking global object leaks"
.IX Subsection "Tracking global object leaks"
.Vb 1
\&  use Devel::LeakGuard::Object qw( GLOBAL_bless );
.Ve
.SS "Finding out what leaked"
.IX Subsection "Finding out what leaked"
If you use \f(CW\*(C`leakguard\*(C'\fR (recommended) then by default a warning is
thrown when leaks are detected. You can customise this behaviour by
passing options to \f(CW\*(C`leakguard\*(C'\fR; see the documentation for \*(L"leakguard\*(R"
for more information.
.PP
If you use \f(CW\*(C`GLOBAL_bless\*(C'\fR or \f(CW\*(C`track\*(C'\fR then you can also specify the
\&\f(CW\*(C`:at_end\*(C'\fR option
.PP
.Vb 1
\&  use Devel::LeakGuard::Object qw( GLOBAL_bless :at_end );
.Ve
.PP
in which case a summary of leaks will be displayed at program exit.
.SS "Load early!"
.IX Subsection "Load early!"
\&\f(CW\*(C`Devel::LeakGuard::Object\*(C'\fR can only track allocations of objects
compiled after it is loaded \- so load it as early as possible.
.SS "What is a leak?"
.IX Subsection "What is a leak?"
This module counts the number of blessed instances of each tracked
class. When we talk about a 'leak' what we really mean here is an
imbalance in the number of allocated objects across some boundary. Using
this definition we see a leak even in the case of expected imbalances.
.PP
When interpreting the results you need to remember that it may be quite
legitimate for certain allocations to live beyond the scope of the code
under test.
.PP
You can use the various options that \f(CW\*(C`leakguard\*(C'\fR supports to filter
out such legitimate allocations that live beyond the life of the block
being checked.
.SS "Performance"
.IX Subsection "Performance"
As soon as \f(CW\*(C`Devel::LeakGuard::Object\*(C'\fR is loaded \f(CW\*(C`bless\*(C'\fR is overloaded.
That means that \f(CW\*(C`bless\*(C'\fR gets a little slower everywhere. When not
actually tracking the overloaded \f(CW\*(C`bless\*(C'\fR is quite fast \- but still
around four times slower than the built-in \f(CW\*(C`bless\*(C'\fR.
.PP
Bear in mind that \f(CW\*(C`bless\*(C'\fR is fast and unless your program is doing a
huge amount of blessing you're unlikely to notice a difference. On my
machine core bless takes around 0.5 I\*^XS and loading
\&\f(CW\*(C`Devel::LeakGuard::Object\*(C'\fR slows that down to around 2 I\*^XS.
.SH "INTERFACE"
.IX Header "INTERFACE"
.ie n .SS """leakguard"""
.el .SS "\f(CWleakguard\fP"
.IX Subsection "leakguard"
Run a block of code tracking object creation and destruction and report
any leaks at block exit.
.PP
At its simplest \f(CW\*(C`leakguard\*(C'\fR runs a block of code and warns if leaks
are found:
.PP
.Vb 4
\&  leakguard {
\&    my $foo = Foo\->new;
\&    $foo\->{me} = $foo; # leak
\&  };
\&
\&  # Displays this warning:
\&  Object leaks found:
\&    Class Before  After  Delta
\&    Foo        3      4      1
\&  Detected at foo.pl line 23
.Ve
.PP
If you really don't want to leak you can die instead of warning:
.PP
.Vb 5
\&  leakguard {
\&    my $foo = Foo\->new;
\&    $foo\->{me} = $foo; # leak
\&  }
\&  on_leak => \*(Aqdie\*(Aq;
.Ve
.PP
If you need to do something more complex you can pass a coderef to the
\&\f(CW\*(C`on_leak\*(C'\fR option:
.PP
.Vb 10
\&  leakguard {
\&    my $foo = Foo\->new;
\&    $foo\->{me} = $foo; # leak
\&    my $bar = Bar\->new;
\&    $bar\->{me} = $bar; # leak again
\&  }
\&  on_leak => sub {
\&    my $report = shift;
\&    for my $pkg ( sort keys %$report ) {
\&      printf "%s %d %d\en", $pkg, @{ $report\->{$pkg} };
\&    }
\&    # do something
\&  };
.Ve
.PP
In the event of a leak the sub will be called with a reference to a
hash. The keys of the hash are the names of classes that have leaked;
the values are refs to two-element arrays containing the bless count for
that class before and after the block so the example above would print:
.PP
.Vb 2
\&  Foo 0 1
\&  Bar 0 1
.Ve
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Other options are supported. Here's the full list:
.ie n .IP """on_leak""" 4
.el .IP "\f(CWon_leak\fR" 4
.IX Item "on_leak"
What to do if a leak is detected. May be 'warn' (the default), 'die',
\&'ignore' or a code reference. If \f(CW\*(C`on_leak\*(C'\fR is set to 'ignore' no leak
tracking will be performed.
.ie n .IP """only""" 4
.el .IP "\f(CWonly\fR" 4
.IX Item "only"
If you need to concentrate on a subset of classes use \f(CW\*(C`only\*(C'\fR to limit
leak tracking to a subset of classes:
.Sp
.Vb 4
\&  leakguard {
\&    # do stuff
\&  }
\&  only => \*(AqMy::Stuff::*\*(Aq;
.Ve
.Sp
The pattern to match can be a string (with '*' as a shell-style
wildcard), a \f(CW\*(C`Regexp\*(C'\fR, a coderef or a reference to an array of any of
the above. This (improbable) example illustrates all of these:
.Sp
.Vb 8
\&  leakguard {
\&    # do stuff
\&  }
\&  only => [
\&    \*(AqMy::Stuff::*\*(Aq, 
\&    qr{Leaky}, 
\&    sub { length $_ > 20 } 
\&  ];
.Ve
.Sp
That would track classes beginning with 'My::Stuff::', containing
\&'Leaky' or whose length is greater than 20 characters.
.ie n .IP """exclude""" 4
.el .IP "\f(CWexclude\fR" 4
.IX Item "exclude"
To track all classes apart from a few exceptions use \f(CW\*(C`exclude\*(C'\fR. The
\&\f(CW\*(C`exclude\*(C'\fR spec is like an \f(CW\*(C`only\*(C'\fR spec but classes that match will be
excluded from tracking.
.ie n .IP """expect""" 4
.el .IP "\f(CWexpect\fR" 4
.IX Item "expect"
Sometimes a certain amount of 'leakage' is acceptable. Imagine, for
example, an application that maintains a single cached database
connection in a class called \f(CW\*(C`My::DB\*(C'\fR. The connection is created on
demand and deleted after it has been used 100 times \- to be created
again next time it's needed.
.Sp
We could use \f(CW\*(C`exclude\*(C'\fR to ignore this class \- but then we'd miss the
case where something goes wrong and we create 5 connections at a time.
.Sp
Using \f(CW\*(C`exclude\*(C'\fR we can specify that no more than one \f(CW\*(C`My::DB\*(C'\fR should
be created or destroyed:
.Sp
.Vb 6
\&  leakguard {
\&    # do stuff
\&  }
\&  expect => {
\&    \*(AqMy::DB\*(Aq => [ \-1, 1 ] 
\&  };
.Ve
.ie n .SS """state"""
.el .SS "\f(CWstate\fP"
.IX Subsection "state"
Get the current allocation counts for all tracked objects. If
\&\f(CW\*(C`GLOBAL_bless\*(C'\fR is in force this will include all blessed objects. If
you are using the finer-grained tracking tools (\*(L"track\*(R" and
\&\*(L"leakguard\*(R") then only allocations that they cover will be included.
.PP
Returns a reference to a hash with package names as keys and allocation
counts as values.
.ie n .SS """track"""
.el .SS "\f(CWtrack\fP"
.IX Subsection "track"
Track an individual object. Tracking an object increases the allocation count for its package by one. When the object is destroyed the allocation count is decreased by one. Current allocation counts may be retrieved using \*(L"state\*(R".
.PP
If the object is reblessed into a different package the count for the
new package will be incremented and the count for the old package
decremented.
.ie n .SS """status"""
.el .SS "\f(CWstatus\fP"
.IX Subsection "status"
Print out a Devel::Leak::Object style summary of current object
allocations. If you
.PP
.Vb 1
\&  use Devel::LeakGuard::Object qw( GLOBAL_bless :at_end );
.Ve
.PP
then \f(CW\*(C`status\*(C'\fR will be called at program exit to dump a summary of
outstanding allocations.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::Leak::Object
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-devel\-leaktrack\-object@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong  \f(CW\*(C`<andy@hexten.net>\*(C'\fR
.PP
Based on code taken from Adam Kennedy's Devel::Leak::Object which
carries this copyright notice:
.PP
.Vb 1
\&  Copyright 2007 Adam Kennedy.
\&
\&  Rewritten from original copyright 2004 Ivor Williams.
\&
\&  Some documentation also copyright 2004 Ivor Williams.
.Ve
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2009, Andy Armstrong \f(CW\*(C`<andy@hexten.net>\*(C'\fR.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
